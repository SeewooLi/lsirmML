// Generated by using Rcpp::compileAttributes() -> do not edit by hand
// Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#include <RcppArmadillo.h>
#include <Rcpp.h>

using namespace Rcpp;

#ifdef RCPP_USE_GLOBAL_ROSTREAM
Rcpp::Rostream<true>&  Rcpp::Rcout = Rcpp::Rcpp_cout_get();
Rcpp::Rostream<false>& Rcpp::Rcerr = Rcpp::Rcpp_cerr_get();
#endif

// P_lsirm_cpp
NumericVector P_lsirm_cpp(NumericMatrix theta, NumericVector param);
RcppExport SEXP _lsirmML_P_lsirm_cpp(SEXP thetaSEXP, SEXP paramSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< NumericMatrix >::type theta(thetaSEXP);
    Rcpp::traits::input_parameter< NumericVector >::type param(paramSEXP);
    rcpp_result_gen = Rcpp::wrap(P_lsirm_cpp(theta, param));
    return rcpp_result_gen;
END_RCPP
}
// llik_cpp
Rcpp::NumericMatrix llik_cpp(const Rcpp::IntegerVector& data, const Rcpp::NumericMatrix& grid, const Rcpp::NumericVector& item);
RcppExport SEXP _lsirmML_llik_cpp(SEXP dataSEXP, SEXP gridSEXP, SEXP itemSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const Rcpp::IntegerVector& >::type data(dataSEXP);
    Rcpp::traits::input_parameter< const Rcpp::NumericMatrix& >::type grid(gridSEXP);
    Rcpp::traits::input_parameter< const Rcpp::NumericVector& >::type item(itemSEXP);
    rcpp_result_gen = Rcpp::wrap(llik_cpp(data, grid, item));
    return rcpp_result_gen;
END_RCPP
}
// Estep_cpp
Rcpp::List Estep_cpp(const Rcpp::IntegerMatrix& data, const Rcpp::NumericMatrix& item, const Rcpp::NumericMatrix& grid, const Rcpp::NumericVector& prior);
RcppExport SEXP _lsirmML_Estep_cpp(SEXP dataSEXP, SEXP itemSEXP, SEXP gridSEXP, SEXP priorSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const Rcpp::IntegerMatrix& >::type data(dataSEXP);
    Rcpp::traits::input_parameter< const Rcpp::NumericMatrix& >::type item(itemSEXP);
    Rcpp::traits::input_parameter< const Rcpp::NumericMatrix& >::type grid(gridSEXP);
    Rcpp::traits::input_parameter< const Rcpp::NumericVector& >::type prior(priorSEXP);
    rcpp_result_gen = Rcpp::wrap(Estep_cpp(data, item, grid, prior));
    return rcpp_result_gen;
END_RCPP
}
// L1L2_lsirm_cpp
List L1L2_lsirm_cpp(NumericMatrix e_response, NumericVector par, NumericMatrix grid);
RcppExport SEXP _lsirmML_L1L2_lsirm_cpp(SEXP e_responseSEXP, SEXP parSEXP, SEXP gridSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< NumericMatrix >::type e_response(e_responseSEXP);
    Rcpp::traits::input_parameter< NumericVector >::type par(parSEXP);
    Rcpp::traits::input_parameter< NumericMatrix >::type grid(gridSEXP);
    rcpp_result_gen = Rcpp::wrap(L1L2_lsirm_cpp(e_response, par, grid));
    return rcpp_result_gen;
END_RCPP
}

static const R_CallMethodDef CallEntries[] = {
    {"_lsirmML_P_lsirm_cpp", (DL_FUNC) &_lsirmML_P_lsirm_cpp, 2},
    {"_lsirmML_llik_cpp", (DL_FUNC) &_lsirmML_llik_cpp, 3},
    {"_lsirmML_Estep_cpp", (DL_FUNC) &_lsirmML_Estep_cpp, 4},
    {"_lsirmML_L1L2_lsirm_cpp", (DL_FUNC) &_lsirmML_L1L2_lsirm_cpp, 3},
    {NULL, NULL, 0}
};

RcppExport void R_init_lsirmML(DllInfo *dll) {
    R_registerRoutines(dll, NULL, CallEntries, NULL, NULL);
    R_useDynamicSymbols(dll, FALSE);
}
